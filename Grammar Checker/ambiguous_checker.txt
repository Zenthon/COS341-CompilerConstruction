V -> S $
S -> A main { B halt ; C }
A -> epsilon    |   D , A
D -> proc userDefinedName { A B return ; C }
B -> epsilon    |   E ; B
E -> F  |   G   |   I   |   L
F -> J := K
G -> if ( K ) then { B } H
H -> epsilon    |   else { B }
I -> do { B } until ( K )       |       while ( K ) do { B }
J -> output     |   M   |   N
K -> O  |   M   |   N   |   P   |   Q
L -> call userDefinedName
M -> userDefinedName
N -> userDefinedName [ Z
Z -> M ] | O ]
O -> ShortString    |   Number      |   true    |   false
P -> input ( M )    |   not ( K )
Q -> and ( K , K )  |   or ( K , K )    |   eq ( K , K )    |   larger ( K , K )    |    add ( K , K )      |   sub ( K , K )   |   mult ( K , K )
C -> epsilon    |   R ; C
R -> T M    |       arr T [ O ] M
T -> num    |   bool    |   string



// Nullable
Nullable(S) = false
Nullable(A) = true
Nullable(D) = false
Nullable(B) = true
Nullable(E) = false
Nullable(F) = false
Nullable(G) = false
Nullable(H) = false
Nullable(I) = false
Nullable(J) = false
Nullable(K) = false
Nullable(L) = false
Nullable(M) = false
Nullable(N) = false
Nullable(Z) = false
Nullable(O) = false
Nullable(P) = false
Nullable(Q) = false
Nullable(C) = true
Nullable(R) = false
Nullable(T) = false


// First
FIRST(S)    =   FIRST(A) or FIRST(main)
            =   {proc} or {main}
            =   {main, proc}


FIRST(A)    =   FIRST(epsilon) or FIRST(D, A)
            =   {} or FIRST(D)
            =   {proc}


FIRST(D)    =   FIRST(proc userDefinedName { A B return ; C })
            =   FIRST(proc)
            =   {proc}


FIRST(B)    =   FIRST(epsilon) or FIRST(E ; B)
            =   {} or FIRST(E)
            =   {output, userDefinedName, if, do, while, call}


FIRST(E)    =   FIRST(F) or FIRST(G) or FIRST(I) or FIRST(L)
            =   {output, userDefinedName} or {if} or {do, while} or {call}
            =   {output, userDefinedName, if, do, while, call}


FIRST(F)    =   FIRST(J := K)
            =   FIRST(J)
            =   {output, userDefinedName}


FIRST(G)    =   FIRST(if ( K ) then { B } H)
            =   FIRST(if)
            =   {if}


FIRST(H)    =   FIRST(epsilon) or FIRST( else { B } )
            =   {} or First(else)
            =   {else}


FIRST(I)    =   FIRST( do { B } until ( K ) ) or FIRST( while ( K ) do { B } )
            =   FIRST(do) or FIRST(while) 
            =   {do, while}


FIRST(J)    =   FIRST(output) or FIRST(M) or FIRST(N)
            =   {output} or {userDefinedName} or {userDefinedName}
            =   {output, userDefinedName}


FIRST(K)    =   FIRST(O) or FIRST(M) or FIRST(N) or FIRST(P) or FIRST(Q)
            =   {ShortString, Number, true, false} or {userDefinedName} or {input, not} or {and, or, eq, larger, add, sub, mult}
            =   {ShortString, Number, true, false, userDefinedName, input, not, and, or, eq, larger, add, sub, mult}


FIRST(L)    =   FIRST(call userDefinedName)
            =   FIRST(call)
            =   {call}


FIRST(M)    =   FIRST(userDefinedName)
            =   {userDefinedName}


FIRST(N)    =   FIRST(userDefinedName [ Z)
            =   FIRST(userDefinedName)
            =   {userDefinedName}


FIRST(Z)    =   FIRST( M ]) or FIRST( O ])
            =   {userDefinedName} or {ShortString, Number, true, false}
            =   {userDefinedName, ShortString, Number, true, false}

FIRST(O)    =   FIRST(ShortString) or FIRST(Number) or FIRST(true) or FIRST(false)
            =   {ShortString, Number, true, false}


FIRST(P)    =   FIRST( input ( M ) ) or FIRST( not ( K ) )
            =   FIRST(input) or FIRST(not)
            =   {input, not}


FIRST(Q)    =   FIRST( and ( K , K ) ) or FIRST( or ( K , K ) ) or FIRST( eq ( K , K ) ) or FIRST( larger ( K , K ) ) or FIRST( add ( K , K ) ) 
                or FIRST( sub ( K , K ) ) or FIRST( mult ( K , K ) )
            =   FIRST(and) or FIRST(or) or FIRST(eq) or FIRST(larger) or FIRST(add) or FIRST(sub) or FIRST(sub)
            =   {and, or, eq, larger, add, sub, mult}


FIRST(C)    =   FIRST(epsilon) or FIRST(R ; C)
            =   {} or FIRST(R)
            =   {bool, num, string, arr}


FIRST(R)    =   FIRST(T M) or FIRST(arr T [ O ] M)
            =   FIRST(T) or FIRST(arr)
            =   {bool, num, string} or {arr}
            =   {bool, num, string, arr}


FIRST(T)    =   FIRST(bool) or FIRST(num) or FIRST(string)
            =   {bool, num, string}


//  Follow
FOLLOW(S)    =   {$}


FOLLOW(A)    =   {main} or FIRST(B) or {return}
            =   {main, return} or {output, userDefinedName, if, do, while, call}
            =   {main, return, output, userDefinedName, if, do, while, call}


FOLLOW(D)    =   {,}


FOLLOW(B)    =   {halt} or {return} or { } }
            =   {halt, return, } }


FOLLOW(E)    =   {;}


FOLLOW(F)    =   FOLLOW(E)
            =   {;}


FOLLOW(G)    =   FOLLOW(E)
            =   {;}


FOLLOW(H)    =   FOLLOW(G)
            =   {;}


FOLLOW(I)    =   FOLLOW(E)
            =   {;}


FOLLOW(J)    =   { := }


FOLLOW(K)    =   FOLLOW(F) or { ) } or { , }
            =   { ;, ), , }


FOLLOW(L)    =   FOLLOW(E)
            =   {;}


FOLLOW(M)    =   FOLLOW(J) or FOLLOW(K) or { ] } or { ) } or FOLLOW(R)
            =   { := } or { ;, ), , } or { ] } or { ) } or  {;}
            =   {:=, ;, ), ], ,}


FOLLOW(N)    =   FOLLOW(J) or FOLLOW(K)
            =   {;, ), ,} or { := }
            =   {; ,), :=, ,}


FOLLOW(Z)    =   FOLLOW(N)
            =   {; ,), :=, ,}


FOLLOW(O)    =   FOLLOW(K) or { ] }
            =   { ;, ), , } or { ] }
            =   {;, ), ], ,}


FOLLOW(P)    =   FOLLOW(K)
            =   { ;, ), , }


FOLLOW(Q)    =   FOLLOW(K)
            =   { ;, ), , }   


FOLLOW(C)    =   { } } 


FOLLOW(R)    =   {;}


FOLLOW(T)    =   FIRST(M) or { [ }
            =   {userDefinedName} or { [ }
            =   { userDefinedName, [ }


//  LookAhead Sets
LA (S -> A main { B halt ; C })                                             =   FIRST(A) or {main}
                                                                            =   {proc} or {main}
                                                                            =   {main, proc)


LA (A -> epsilon)                                                           =   FIRST(epsilon) or FOLLOW(A)
                                                                            =   {main, return, output, userDefinedName, if, do, while, call}   


LA (A -> D , A)                                                             =   FIRST(D)
                                                                            =   {proc}


LA (D -> proc userDefinedName { A B return ; C } )                          =   FIRST(proc)
                                                                            =   {proc}


LA (B -> epsilon)                                                           =   FIRST(epsilon) or FOLLOW(B)
                                                                            =   {halt, return, } }    


LA (B -> E ; B)                                                             =   FIRST(E)
                                                                            =   {output, userDefinedName, if, do, while, call}


LA (E -> F)                                                                 =   FIRST(F)
                                                                            =   {output, userDefinedName}


LA (E -> G)                                                                 =   FIRST(G)
                                                                            =   {if}


LA (E -> I)                                                                 =   FIRST(I)
                                                                            =   {do, while}


LA (E -> L)                                                                 =   FIRST(L)
                                                                            =   {call}


LA (F -> J := K)                                                            =   FIRST(J)
                                                                            =   {output, userDefinedName}


LA (G -> if ( K ) then { B } H)                                             =   FIRST(if)
                                                                            =   {if}


LA (H -> epsilon)                                                           =   FIRST(epsilon) or FOLLOW(H)
                                                                            =   {;}


LA (H -> else { B })                                                        =   FIRST(else)
                                                                            =   {else}


LA (I -> do { B } until ( K ) )                                             =   FIRST(do)       
                                                                            =   {do}


LA (I -> while ( K ) do { B })                                              =   FIRST(while)
                                                                            =   {while}


LA (J -> output)                                                            =   FIRST(output)
                                                                            =   {output}     


LA (J -> M)                                                                 =   FIRST(M)
                                                                            =   {userDefinedName}


LA (J -> N)                                                                 =   FIRST(N)
                                                                            =   {userDefinedName}


LA (K -> O)                                                                 =   FIRST(O)
                                                                            =   {ShortString, Number, true, false}    


LA (K -> M)                                                                 =   FIRST(M)
                                                                            =   {userDefinedName}


LA (K -> N)                                                                 =   FIRST(N)
                                                                            =   {userDefinedName}


LA (K -> P)                                                                 =   FIRST(P)
                                                                            =   {input, not}


LA (K -> Q)                                                                 =   FIRST(Q)
                                                                            =   {and, or, eq, larger, add, sub, mult}


LA (L -> call userDefinedName)                                              =   FIRST(call)
                                                                            =   {call}


LA (M -> userDefinedName)                                                   =   FIRST(userDefinedName)
                                                                            =   {userDefinedName}


LA (N -> userDefinedName [ Z)                                               =   FIRST(userDefinedName)
                                                                            =   {userDefinedName}


LA (Z -> M ])                                                               =   FIRST(M)
                                                                            =   {userDefinedName}


LA (Z -> O ])                                                               =   FIRST(O)
                                                                            =   {ShortString, Number, true, false}


LA (O -> ShortString)                                                       =   FIRST(ShortString)
                                                                            =   {ShortString}


LA (O -> Number                                                             =   FIRST(Number)
                                                                            =   {Number}


LA (O -> true)                                                              =   FIRST(true)
                                                                            =   {true}                                                              


LA (O -> false)                                                             =   FIRST(false)
                                                                            =   {false}


LA (P -> input ( M ) )                                                      =   FIRST(input)
                                                                            =   {input}   


LA (P -> not ( K ) )                                                        =   FIRST(not)
                                                                            =   {not}


LA (Q -> and ( K , K ) )                                                    =   FIRST(and)
                                                                            =   {and}


LA (Q -> or ( K , K ) )                                                     =   FIRST(or)
                                                                            =   {or}


LA (Q -> eq ( K , K ) )                                                     =   FIRST(eq)
                                                                            =   {eq}


LA (Q -> larger ( K , K ) )                                                 =   FIRST(larger)
                                                                            =   {larger}


LA (Q -> add ( K , K ) )                                                    =   FIRST(add)
                                                                            =   {add}


LA (Q -> sub ( K , K ) )                                                    =   FIRST(sub)
                                                                            =   {sub}


LA (Q -> mult ( K , K ) )                                                   =   FIRST(mult)
                                                                            =   {mult}


LA (C -> epsilon )                                                          =   FIRST(epsilon) or FOLLOW(C)
                                                                            =   { } }


LA (C -> R ; C)                                                             =   FIRST(R)
                                                                            =   {bool, num, string, arr}


LA (R -> T M)                                                               =   FIRST(T)
                                                                            =   {bool, num, string}


LA (R -> arr T [ O ] M)                                                     =   FIRST(arr)
                                                                            =   {arr}


LA (T -> num)                                                               =   FIRST(num)
                                                                            =   {num}


LA (T -> bool)                                                              =   FIRST(bool)
                                                                            =   {bool}


LA (T -> string)                                                            =   FIRST(string)
                                                                            =   {string}                                                            
